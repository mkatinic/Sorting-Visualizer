(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{10:function(e,t,r){e.exports=r(19)},19:function(e,t,r){"use strict";r.r(t);var n=r(0),o=r.n(n),a=r(4),i=r.n(a),c=(r(3),r(1)),u=r(5),l=r(6),s=r(8),m=r(7),h=r(9);function p(e){var t=[];return function e(t,r,n,o){if(r>=n)return;var a=function(e,t,r,n){var o=e[Math.floor((t+r)/2)];e[Math.floor((t+r)/2)]=e[t];for(;t<r;){for(;t<r&&e[r]>=o;)n.push([t,r,"comp"]),n.push([t,r,"comp"]),r--;for(e[t]=e[r],n.push([t,e[t]]);t<r&&e[t]<=o;)n.push([t,r,"comp"]),n.push([t,r,"comp"]),t++;e[r]=e[t],n.push([r,e[r]])}return e[r]=o,n.push([r,e[r]]),t}(t,r,n,o);e(t,r,a,o);e(t,a+1,n,o)}(e,0,e.length-1,t),t}function y(e){var t=[];if(e.length<=1)return e;var r=e.slice();return function e(t,r,n,o,a){if(r===n)return;var i=Math.floor((r+n)/2);e(o,r,i,t,a);e(o,i+1,n,t,a);!function(e,t,r,n,o,a){var i=t,c=t,u=r+1;for(;c<=r&&u<=n;)a.push([c,u,"comp"]),a.push([c,u,"comp"]),o[c]<=o[u]?(a.push([i,o[c]]),e[i++]=o[c++]):(a.push([i,o[u]]),e[i++]=o[u++]);for(;c<=r;)a.push([c,c,"comp"]),a.push([c,c,"comp"]),a.push([i,o[c]]),e[i++]=o[c++];for(;u<=n;)a.push([u,u,"comp"]),a.push([u,u,"comp"]),a.push([i,o[u]]),e[i++]=o[u++]}(t,r,i,n,o,a)}(e,0,e.length-1,r,t),t}var d=function(e){function t(e){var r;return Object(u.a)(this,t),(r=Object(s.a)(this,Object(m.a)(t).call(this,e))).state={array:[]},r}return Object(h.a)(t,e),Object(l.a)(t,[{key:"componentDidMount",value:function(){this.resetArray()}},{key:"resetArray",value:function(){for(var e=[],t=0;t<125;t++)e.push(Math.floor(496*Math.random()+5));this.setState({array:e}),""!==document.querySelector("#algorithm").innerText&&(document.querySelector("#algorithm").innerText="",document.querySelector("#complexity").innerText="",document.querySelector("#bio").innerText="")}},{key:"bubbleSort",value:function(){for(var e=function(e){var t=[];return function(e,t){for(var r=e.length,n=0;n<r;n++)for(var o=0;o<r-n-1;o++)if(t.push([o,o+1,"comp"]),t.push([o,o+1,"comp"]),e[o]>e[o+1]){var a=e[o];e[o]=e[o+1],e[o+1]=a,t.push([o,e[o],o+1,e[o+1]])}else t.push([o,e[o],o+1,e[o+1]])}(e,t),t}(this.state.array),t=0,r=document.getElementsByClassName("array--bar"),n=function(n){if("comp"===e[n][2]){var o=Object(c.a)(e[n],2),a=o[0],i=o[1],u=r[a].style,l=r[i].style,s=t%2===0?"red":"turquoise";t++,setTimeout(function(){u.backgroundColor=s,l.backgroundColor=s},3*n)}else setTimeout(function(){var t=Object(c.a)(e[n],4),o=t[0],a=t[1],i=t[2],u=t[3];r[o].style.height="".concat(a,"px"),r[i].style.height="".concat(u,"px")},3*n)},o=0;o<e.length;o++)n(o);document.querySelector("#algorithm").innerText="Bubble Sort",document.querySelector("#complexity").innerText="Best Time Complexity: O(n) \n Average Time Complexity: O(n^2) \n Worst Time Complexity: O(n^2) \n Space Complexity: O(1)",document.querySelector("#bio").innerText="Bubble Sort is a very simple sorting algorithm that works by swapping the adjascent elements if they are in wrong order. This is not a practical sorting algorithm for large data sets due to its high time complexity"}},{key:"selectionSort",value:function(){for(var e=function(e){var t=[];return function(e,t){for(var r=e.length,n=0;n<r;n++){for(var o=n,a=n+1;a<r;a++)t.push([a,o,"comp"]),t.push([a,o,"comp"]),e[a]<e[o]&&(o=a);if(o!==n){var i=e[n];e[n]=e[o],e[o]=i,t.push([n,e[n],o,e[o]])}}}(e,t),t}(this.state.array),t=0,r=document.getElementsByClassName("array--bar"),n=function(n){if("comp"===e[n][2]){var o=Object(c.a)(e[n],2),a=o[0],i=o[1],u=r[a].style,l=r[i].style,s=t%2===0?"red":"turquoise";t++,setTimeout(function(){u.backgroundColor=s,l.backgroundColor=s},3*n)}else setTimeout(function(){var t=Object(c.a)(e[n],4),o=t[0],a=t[1],i=t[2],u=t[3];r[o].style.height="".concat(a,"px"),r[i].style.height="".concat(u,"px")},3*n)},o=0;o<e.length;o++)n(o);document.querySelector("#algorithm").innerText="Selection Sort",document.querySelector("#complexity").innerText="Best Time Complexity: O(n^2) \n Average Time Complexity: O(n^2) \n Worst Time Complexity: O(n^2) \n Space Complexity: O(1)",document.querySelector("#bio").innerText="The selection sort algorithm works by repeatedly finding the minimum element from the unsorted part of the array and placing it at the front of the array. This is not a practical sorting algorithm for large data sets due to its high time complexity"}},{key:"quickSort",value:function(){for(var e=p(this.state.array),t=0,r=document.getElementsByClassName("array--bar"),n=function(n){if("comp"===e[n][2]){var o=Object(c.a)(e[n],2),a=o[0],i=o[1],u=r[a].style,l=r[i].style,s=t%2===0?"red":"turquoise";t++,setTimeout(function(){u.backgroundColor=s,l.backgroundColor=s},3*n)}else setTimeout(function(){var t=Object(c.a)(e[n],2),o=t[0],a=t[1];r[o].style.height="".concat(a,"px")},3*n)},o=0;o<e.length;o++)n(o);document.querySelector("#algorithm").innerText="Quick Sort",document.querySelector("#complexity").innerText="Best Time Complexity: O(nlogn) \n Average Time Complexity: O(nlogn) \n Worst Time Complexity: O(n^2) \n Space Complexity: O(n)",document.querySelector("#bio").innerText="The quick sort algorithm uses the divide and conquer technique. It will pick an element as a pivot and will partition the given arrays around the pivot. There are different versions of the quick sort algorithm which pick the pivot in different locations, for this algorithm I used the middle index of the arrays as my pivot."}},{key:"mergeSort",value:function(){for(var e=y(this.state.array),t=0,r=document.getElementsByClassName("array--bar"),n=function(n){if("comp"===e[n][2]){var o=Object(c.a)(e[n],2),a=o[0],i=o[1],u=r[a].style,l=r[i].style,s=t%2===0?"red":"turquoise";t++,setTimeout(function(){u.backgroundColor=s,l.backgroundColor=s},3*n)}else setTimeout(function(){var t=Object(c.a)(e[n],2),o=t[0],a=t[1];r[o].style.height="".concat(a,"px")},3*n)},o=0;o<e.length;o++)n(o);document.querySelector("#algorithm").innerText="Merge Sort",document.querySelector("#complexity").innerText="Best Time Complexity: O(nlogn) \n Average Time Complexity: O(nlogn) \n Worst Time Complexity: O(nlogn) \n Space Complexity: O(n)",document.querySelector("#bio").innerText="Merge Sort is a sorting algorithm which uses a divide and conquer strategy. This algorithm will recursivly divide the array into two equal halves, and keep dividing until it cannot be further divided, then they are combined as a sorted array."}},{key:"render",value:function(){var e=this,t=this.state.array;return o.a.createElement("div",{className:"array--container"},o.a.createElement("div",{className:"array--column"},o.a.createElement("div",{className:"array--bars"},t.map(function(e,t){return o.a.createElement("div",{className:"array--bar",key:t,style:{backgroundColor:"turquoise",height:"".concat(e,"px")}})}),o.a.createElement("div",{className:"array--buttons"},o.a.createElement("button",{onClick:function(){return e.resetArray()}},"Generate New Array"),o.a.createElement("button",{onClick:function(){return e.bubbleSort()}},"Bubble Sort"),o.a.createElement("button",{onClick:function(){return e.selectionSort()}},"Selection Sort"),o.a.createElement("button",{onClick:function(){return e.quickSort()}},"Quick Sort"),o.a.createElement("button",{onClick:function(){return e.mergeSort()}},"Merge Sort")))),o.a.createElement("div",{className:"array--column"},o.a.createElement("h1",null,"About the Algorithm"),o.a.createElement("div",{className:"array--bio"},o.a.createElement("p",{id:"algorithm"}),o.a.createElement("p",{id:"complexity"}),o.a.createElement("p",{id:"bio"}))))}}]),t}(o.a.Component);var f=function(){return o.a.createElement("div",{className:"App"},o.a.createElement(d,null))};i.a.render(o.a.createElement(f,null),document.getElementById("root"))},3:function(e,t,r){}},[[10,2,1]]]);
//# sourceMappingURL=main.f55c834d.chunk.js.map