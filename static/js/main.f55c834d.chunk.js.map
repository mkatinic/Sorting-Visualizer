{"version":3,"sources":["components/Algorithms/quickSort.js","components/Algorithms/mergeSort.js","components/Main.js","components/Algorithms/bubbleSort.js","components/Algorithms/selectionSort.js","App.js","index.js"],"names":["getQuickSortAnimations","array","animations","quickSort","low","high","piv","pivot","Math","floor","push","partition","length","getMergeSortAnimations","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","k","i","j","doMerge","SortingVisualizer","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","resetArray","random","setState","document","querySelector","innerText","len","tmp","bubbleSort","getBubbleSortAnimations","colorChangeCounter","arrayBars","getElementsByClassName","_loop","_animations$i","slicedToArray","barOneIdx","barTwoIdx","barOneStyle","style","barTwoStyle","color","setTimeout","backgroundColor","_animations$i2","barOneHeight","barTwoHeight","height","concat","n","min","selectionSort","getSelectionSortAnimations","_loop2","_animations$i3","_animations$i4","_loop3","_animations$i5","_animations$i6","_loop4","_animations$i7","_animations$i8","newHeight","_this2","react_default","a","createElement","className","map","value","idx","key","onClick","mergeSort","id","React","Component","App","Main_SortingVisualizer","ReactDOM","render","src_App","getElementById"],"mappings":"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","file":"static/js/main.f55c834d.chunk.js","sourcesContent":["export function getQuickSortAnimations(array) {\n  const animations = [];\n  quickSort(array, 0, array.length - 1, animations);\n\n  function partition(array, low, high, animations) {\n    let pivot = array[Math.floor((low + high) / 2)];\n    array[Math.floor((low + high) / 2)] = array[low];\n\n    while (low < high) {\n      while (low < high && array[high] >= pivot) {\n        // These are the values that we're comparing; we push them twice\n        // to change their color.\n        animations.push([low, high, \"comp\"]);\n        animations.push([low, high, \"comp\"]);\n        high--;\n      }\n      array[low] = array[high];\n      // Overwrite the values and add to the animations array.\n      animations.push([low, array[low]]);\n\n      while (low < high && array[low] <= pivot) {\n        // These are the values that we're comparing; we push them twice\n        // to change their color.\n        animations.push([low, high, \"comp\"]);\n        animations.push([low, high, \"comp\"]);\n        low++;\n      }\n      array[high] = array[low];\n      // Overwrite the values and add to the animations array.\n      animations.push([high, array[high]]);\n    }\n    array[high] = pivot;\n    // Overwrite the values and add to the animations array.\n    animations.push([high, array[high]]);\n    return low;\n  }\n\n\n  function quickSort(array, low, high, animations) {\n    if (low >= high) {\n      return;\n    }\n    let piv = partition(array, low, high, animations);\n    quickSort(array, low, piv, animations);\n    quickSort(array, piv + 1, high, animations);\n\n  }\n  return animations;\n}\n\n\n","export function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(\n  mainArray,\n  startIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(\n  mainArray,\n  startIdx,\n  middleIdx,\n  endIdx,\n  auxiliaryArray,\n  animations,\n) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    // These are the values that we're comparing; we push them twice\n    // to change their color.\n    animations.push([i, j, \"comp\"]);\n    animations.push([i, j, \"comp\"]);\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      // Overwrite the values and add to the animations array.\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      // Overwrite the values and add to the animations array.\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    // These are the values that we're comparing; we push them twice\n    // to change their color.\n    animations.push([i, i, \"comp\"]);\n    animations.push([i, i, \"comp\"]);\n\n    // Overwrite the values and add to the animations array.\n    animations.push([k, auxiliaryArray[i]]);\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them twice\n    // to change their color.\n    animations.push([j, j, \"comp\"]);\n    animations.push([j, j, \"comp\"]);\n\n    // Overwrite the values and add to the animations array.\n    animations.push([k, auxiliaryArray[j]]);\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}\n","import React from 'react';\nimport { getBubbleSortAnimations } from './Algorithms/bubbleSort';\nimport { getSelectionSortAnimations } from './Algorithms/selectionSort';\nimport { getQuickSortAnimations } from './Algorithms/quickSort';\nimport { getMergeSortAnimations } from './Algorithms/mergeSort';\nimport '../index.css';\n\n// Change this value for the speed of the animations.\nconst ANIMATION_SPEED_MS = 3;\n\n// Change this value for the number of bars (value) in the array.\nconst NUMBER_OF_ARRAY_BARS = 125;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = 'turquoise';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = 'red';\n\nexport default class SortingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: [],\n    };\n  }\n\n  componentDidMount() {\n    this.resetArray();\n  }\n\n  resetArray() {\n    const array = [];\n    for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n      array.push(Math.floor(Math.random() * (500 - 5 + 1) + 5));\n    }\n    this.setState({ array });\n    if(document.querySelector('#algorithm').innerText !== \"\"){\n      document.querySelector('#algorithm').innerText = \"\";\n      document.querySelector('#complexity').innerText = \"\";\n      document.querySelector('#bio').innerText = \"\";\n    }\n  }\n\n  bubbleSort() {\n    const animations = getBubbleSortAnimations(this.state.array);\n    let colorChangeCounter = 0;\n    const arrayBars = document.getElementsByClassName('array--bar');\n    for (let i = 0; i < animations.length; i++) {\n      if (animations[i][2] === \"comp\") {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = colorChangeCounter % 2 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        colorChangeCounter++;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, barOneHeight, barTwoIdx, barTwoHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${barOneHeight}px`;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          barTwoStyle.height = `${barTwoHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n    document.querySelector('#algorithm').innerText = \"Bubble Sort\";\n    document.querySelector('#complexity').innerText = 'Best Time Complexity: O(n) \\n Average Time Complexity: O(n^2) \\n Worst Time Complexity: O(n^2) \\n Space Complexity: O(1)';\n    document.querySelector('#bio').innerText = \"Bubble Sort is a very simple sorting algorithm that works by swapping the adjascent elements if they are in wrong order. \" +\n    \"This is not a practical sorting algorithm for large data sets due to its high time complexity\";\n  }\n\n  selectionSort() {\n    const animations = getSelectionSortAnimations(this.state.array);\n    let colorChangeCounter = 0;\n    const arrayBars = document.getElementsByClassName('array--bar');\n    for (let i = 0; i < animations.length; i++) {\n      if (animations[i][2] === \"comp\") {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = colorChangeCounter % 2 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        colorChangeCounter++;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, barOneHeight, barTwoIdx, barTwoHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${barOneHeight}px`;\n          const barTwoStyle = arrayBars[barTwoIdx].style;\n          barTwoStyle.height = `${barTwoHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n    document.querySelector('#algorithm').innerText = \"Selection Sort\";\n    document.querySelector('#complexity').innerText = 'Best Time Complexity: O(n^2) \\n Average Time Complexity: O(n^2) \\n Worst Time Complexity: O(n^2) \\n Space Complexity: O(1)';\n    document.querySelector('#bio').innerText = \"The selection sort algorithm works by repeatedly finding the minimum element from the unsorted part of the array and placing \" +\n    \"it at the front of the array. This is not a practical sorting algorithm for large data sets due to its high time complexity\";\n  }\n\n  quickSort() {\n    const animations = getQuickSortAnimations(this.state.array);\n    let colorChangeCounter = 0;\n    const arrayBars = document.getElementsByClassName('array--bar');\n    for (let i = 0; i < animations.length; i++) {\n      if (animations[i][2] === \"comp\") {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = colorChangeCounter % 2 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        colorChangeCounter++;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, barOneHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${barOneHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n    document.querySelector('#algorithm').innerText = \"Quick Sort\";\n    document.querySelector('#complexity').innerText = 'Best Time Complexity: O(nlogn) \\n Average Time Complexity: O(nlogn) \\n Worst Time Complexity: O(n^2) \\n Space Complexity: O(n)';\n    document.querySelector('#bio').innerText = \"The quick sort algorithm uses the divide and conquer technique. It will pick an element as a pivot and will partition the given \" +\n    \"arrays around the pivot. There are different versions of the quick sort algorithm which pick the pivot in different locations, for this algorithm I used \" +\n    \"the middle index of the arrays as my pivot.\";\n  }\n\n  mergeSort() {\n    const animations = getMergeSortAnimations(this.state.array);\n    let colorChangeCounter = 0;\n    const arrayBars = document.getElementsByClassName('array--bar');\n    for (let i = 0; i < animations.length; i++) {\n      if (animations[i][2] === \"comp\") {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = colorChangeCounter % 2 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        colorChangeCounter++;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n   document.querySelector('#algorithm').innerText = \"Merge Sort\";\n   document.querySelector('#complexity').innerText = 'Best Time Complexity: O(nlogn) \\n Average Time Complexity: O(nlogn) \\n Worst Time Complexity: O(nlogn) \\n Space Complexity: O(n)';\n   document.querySelector('#bio').innerText = \"Merge Sort is a sorting algorithm which uses a divide and conquer strategy. This algorithm will recursivly\" +\n   \" divide the array into two equal halves, and keep dividing until it cannot be further divided, then they are combined as a sorted array.\";\n  }\n\n  render() {\n    const { array } = this.state;\n    return (\n      <div className='array--container'>\n        <div className='array--column'>\n          <div className=\"array--bars\">\n            {array.map((value, idx) => (\n              <div\n                className=\"array--bar\"\n                key={idx}\n                style={{\n                  backgroundColor: PRIMARY_COLOR,\n                  height: `${value}px`,\n                }}></div>\n            ))}\n            <div className=\"array--buttons\">\n              <button onClick={() => this.resetArray()}>Generate New Array</button>\n              <button onClick={() => this.bubbleSort()}>Bubble Sort</button>\n              <button onClick={() => this.selectionSort()}>Selection Sort</button>\n              <button onClick={() => this.quickSort()}>Quick Sort</button>\n              <button onClick={() => this.mergeSort()}>Merge Sort</button>\n            </div>\n          </div>\n        </div>\n        <div className='array--column'>\n          <h1>About the Algorithm</h1>\n          <div className='array--bio'>\n            <p id='algorithm'></p>\n            <p id='complexity'></p>\n            <p id='bio'></p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}","export function getBubbleSortAnimations(array) {\n    const animations = [];\n    bubbleSort(array, animations);\n\n    function bubbleSort(array, animations) {\n        let len = array.length;\n        for (let i = 0; i < len; i++) {\n            for (let j = 0; j < (len - i - 1); j++) {\n                // These are the values that we're comparing; we push them twice\n                // to change their color.\n                animations.push([j, j + 1, \"comp\"]);\n                animations.push([j, j + 1, \"comp\"]);\n\n                if (array[j] > array[j + 1]) {\n                    let tmp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = tmp;\n                    // Overwrite the values and add to the animations array.\n                    animations.push([j, array[j], j + 1, array[j + 1]]);\n                } else {\n                    animations.push([j, array[j], j + 1, array[j + 1]]);\n                }\n            }\n        }\n    }\n\n    return animations;\n};\n\n\n","export function getSelectionSortAnimations(array){\n    const animations = [];\n    selectionSort(array, animations);\n\n    function selectionSort(array, animations) { \n        let n = array.length;\n            \n        for(let i = 0; i < n; i++) {\n            // Finding the smallest number in the subarray\n            let min = i;\n            for(let j = i+1; j < n; j++){\n                animations.push([j, min, \"comp\"]);\n                animations.push([j, min, \"comp\"]);\n                if(array[j] < array[min]) {\n                    min=j; \n                }\n             }\n             if (min !== i) {\n                 // Swapping the elements\n                 let tmp = array[i]; \n                 array[i] = array[min];\n                 array[min] = tmp;    \n                 animations.push([i, array[i], min, array[min]]);  \n            }\n        }\n        return array;\n    }\n\n    return animations;\n}","import React from 'react';\nimport SortingVisualizer from './components/Main';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}